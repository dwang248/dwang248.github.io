---
title: "CMSC320 Final Project"
author: David Wang, Steve Jettoo
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Ingesting and Tidying Data

```{r start}
library(tidyverse)
library(rvest)
library(dplyr)
library(tidyr)
library(stringr)
library(crypto)

crypto_hist <- crypto_history(coin = "bitcoin", limit = NULL, start_date = "20170427", end_date ="20190228")

colnames(crypto_hist)[colnames(crypto_hist)=="date"] <- "Date"
 
crypto_hist
```



```{r excel_data}
library(readxl)

CMSC320_Crypto_Data <- read_excel("CMSC320 Crypto Data.xlsx")
excel_data <- data.frame(CMSC320_Crypto_Data) %>%
   mutate(Date = as.Date(Date, format="%Y-%m-%d"))
excel_data

```

Next, read the data from "CMSC320 Crypto Data.xlsx". This dataset is an excel spreadsheet. The data within the excel spreadsheet is data from various sources. 

These are the attributes within the dataset and a short explanation of what they are:
TxPerDay: Number of Transaction over a 24 hour period. 
AvgFee: Daily aggregate fee added to transaction (transaction cost)
Hashrate: Daily relative measure of network's processing power in trillions of terahashes per second
Diff: Daily mathematical value of how hard it is to find a valid hash for a block
ResElec: Daily residential Electricity Price in cents/kWh
CommElec: Daily commercial Electricity Price in cents/kWh
FFR: Federal Funds Rate or the interest rate at which banks lend reserve balances to other banks overnight
Trending: Daily measure of interest in bitcoin over time (from Google trends)
Infl: Inflation Rate; used as a macroeconomic indicator on the impact of price changes on Bitcoin value
TT: A unique identifier for every observation

To import an excel spreadsheet onto R, one must first have the package library readxl installed. The package readxl allows R to easily access the data within Excel. We will use the function 'read_excel' to read the xlsx file. Once we have the excel file in R, we will transform it so that it becomes a data frame. This is so we are able to manipulate the data within the excel sheet. We will use the function 'data.frame' to transform the xlsx file into a data frame.

Notice that the type for the attribute Date is different than the one in the first dataset. It is essential for the Date attributes from the two datasets to be the same type in order for them to merge with each other. The 'mutate' function allows us to create new attributes based on the result of a given expression. We will use 'mutate' to transform Date into a type <date>. The expression we will use in the 'mutate' function will be the 'as.Date' function, which will convert character data to dates. The 'as.Date' function will allow us to convert the Date attribute into type date. 

Once the Date attribute has been converted into type date, we now have a data set that can be merged with our previous dataset.

```{r merge_data}
cryto_merge <- crypto_hist %>%
  left_join(excel_data, by = "Date") 
cryto_merge
```

We will now merge the two datasets together using their Date attribute. To do this, we will be using the 'join' operation. The 'join' operation allows us to merge the rows of two data sets forming one data set, given a matching attribute from the two data sets. The join operation that we will be mainly using is the 'left_join' operation. 'left_join' will merge the two data sets together; however, all observations on the left hand side or the first data set are retained.   

```{r DJW}
# Gets stock data from yahoo
# install.packages("quantmod")

library(tidyverse)
library(rvest)
library(quantmod)

# Scrape Data from yahoo finance
getSymbols("^DJI", from = "2017-4-27", to = "2019-2-28")

# Set it as a data frame
DJI_data <- data.frame(DJI) 
DJI_data

# Date is set as a row name. We need to change this so that Date becomes an attribute. This will be neccessary if we want to merge the stock data with the bitcoin data

# Add a column name to the dates as well as change the names for the rest of the attributes
DJI_data <- cbind(rownames(DJI_data), DJI_data)
# Removes the row name
rownames(DJI_data) <- NULL
colnames(DJI_data) <- c("Date","DJI_Open","DJI_High", "DJI_Low", "DJI_Close", "DJI_Volume", "DJI_Adjusted")

DJI_data 
```

DJI_Open: The opening price of a stock of the Dow Jones Industrial Average

DJI_Close: The closing price of a stock of the Dow Jones Industrial Average

DJI_Volume: The number of Dow Jones Industrial Average shares that changed hands during a given day

DJI_Adjusted: The adjusted closing price of a stock of the Dow Jones Industrial Average taking into account any corporate actions

```{r NVDA}
# Repeat for NVIDIA stock
getSymbols("NVDA", from = "2017-4-27", to = "2019-2-28")

NVDA_data <- data.frame(NVDA) 
NVDA_data

NVDA_data <- cbind(rownames(NVDA_data), NVDA_data)

rownames(NVDA_data) <- NULL
colnames(NVDA_data) <- c("Date","NVDA_Open","NVDA_High", "NVDA_Low", "NVDA_Close", "NVDA_Volume", "NVDA_Adjusted")

NVDA_data
```

NVDA_Open: The opening price of a stock of Nvidia

NVDA_Close: The closing price of a stock of the Nvidia

NVDA_Volume: The number of Nvidia shares that changed hands during a given day

NVDA_Adjusted: The adjusted closing price of a stock of the Nvidia taking into account any corporate actions

```{r merge_stocks}
stock_data <- NVDA_data %>%
  left_join(DJI_data, by="Date") %>%
  mutate(Date = as.Date(Date, format="%Y-%m-%d"))
stock_data
```


```{r merge_stock}
crypto_data <- cryto_merge %>%
  left_join(stock_data, by="Date")
crypto_data
```

## Missing Data: Imputation
A common approach is to add an additional indicator variable stating if numeric missing value was imputed

```{r indicate_missing}
cryp_up <- crypto_data %>%
  mutate(stock_missing = is.na(NVDA_Open))
  
crypto_data <- cryp_up
crypto_data
```


In the case of numeric values, we can use a simple method for imputation where we replace missing values for a variable with, for instance, the mean of non-missing values

```{r missing}
crypto_data$NVDA_Open[is.na(crypto_data$NVDA_Open)] <- mean(crypto_data$NVDA_Open, na.rm=TRUE)
crypto_data$NVDA_High[is.na(crypto_data$NVDA_High)] <- mean(crypto_data$NVDA_High, na.rm=TRUE)
crypto_data$NVDA_Low[is.na(crypto_data$NVDA_Low)] <- mean(crypto_data$NVDA_Low, na.rm=TRUE)
crypto_data$NVDA_Close[is.na(crypto_data$NVDA_Close)] <- mean(crypto_data$NVDA_Close, na.rm=TRUE)
crypto_data$NVDA_Volume[is.na(crypto_data$NVDA_Volume)] <- mean(crypto_data$NVDA_Volume, na.rm=TRUE)
crypto_data$NVDA_Adjusted[is.na(crypto_data$NVDA_Adjusted)] <- mean(crypto_data$NVDA_Adjusted, na.rm=TRUE)

crypto_data$DJI_Open[is.na(crypto_data$DJI_Open)] <- mean(crypto_data$DJI_Open, na.rm=TRUE)
crypto_data$DJI_High[is.na(crypto_data$DJI_High)] <- mean(crypto_data$DJI_High, na.rm=TRUE)
crypto_data$DJI_Low[is.na(crypto_data$DJI_Low)] <- mean(crypto_data$DJI_Low, na.rm=TRUE)
crypto_data$DJI_Close[is.na(crypto_data$DJI_Close)] <- mean(crypto_data$DJI_Close, na.rm=TRUE)
crypto_data$DJI_Volume[is.na(crypto_data$DJI_Volume)] <- mean(crypto_data$DJI_Volume, na.rm=TRUE)
crypto_data$DJI_Adjusted[is.na(crypto_data$DJI_Adjusted)] <- mean(crypto_data$DJI_Adjusted, na.rm=TRUE)

crypto_data
```

Imputing missing values has two effects. First, the central tendency of data is retained, for example, if we impute missing data using the mean of a numeric variable, the mean after imputation will not change. This is a good reason to impute based on estimates of central tendency. However, the spread of the data will change. After imputation, the spread of the data will be smaller relative to spread if we ignore missing values. This could be problematic as underestimating the spread of data can yield over-confident inferences in downstream analysis. We will not address these issues directly in later chapters, but you should be aware of this.

## Regressions

We will run a regression with the closing price of Bitcoin, close, as our dependent variable. 

```{r regression}
price <- lm(log(close) ~ log(volume) + spread + log(TxPerDay) + log(AvgFee) + log(Hashrate) + log(Diff) + ResElec + CommElec + FFR + log(Trending) + Infl + log(NVDA_Adjusted) + log(DJI_Adjusted), data = crypto_data)

broom::tidy(price)
```

On average, holding everything else constant, a one percent increase in volume will increase the price of Bitcoin by 0.392696910479%.

On average, 


## Regression Analysis

```{r fitted}
check <- broom::augment(price) 
check %>%
  ggplot(aes(x=.fitted, y=.resid)) +
    geom_point() +
    geom_smooth() +
    labs(title="Fitted vs. Residuals",
         x = "fitted",
         y = "residuals")
```


## Random Forest

```{r forest}
set.seed(1234)
new_cryp <- na.omit(crypto_data)
train_indices <- sample(nrow(new_cryp), nrow(new_cryp)/2)
train_set <- new_cryp[train_indices,]
test_set <- new_cryp[-train_indices,]

library(randomForest)

cryp_rf <- randomForest(close ~ volume + spread + TxPerDay + AvgFee + Hashrate + Diff + ResElec + CommElec + FFR + Trending + Infl + NVDA_Adjusted + DJI_Adjusted, importance=TRUE, mtry=3, data=train_set)

plot(cryp_rf)
```

```{r interpret}
variable_importance <- importance(cryp_rf)
knitr::kable((round(variable_importance, digits=2)))
```

```{r plot}
varImpPlot(cryp_rf)
```

## Leaflet Visualization
```{r Local Volume Data}
# need readxl library
library(readxl)

# read excel on local volume data in repository
volume_data <- read_excel("localvolumedata.xlsx")

# Our Data came out a bit wonky, so lets clean it up.
volume_data_df <- volume_data %>%
  as_data_frame()

# Regexpression
countryrexp <- "([A-Z]+[a-z]*)(\\s)*([A-Z]{1}[a-z]+)*.*"

# Clean up Country Data Values
# Change the name of some countries to make joining data easier
localvolumedata <- volume_data_df %>%
  mutate(Country = str_extract(Country,countryrexp))

# Change the name of some countries to make joining data easier
localvolumedata$Country[localvolumedata$Country == "USA"] <- "United States of America"
localvolumedata$Country[localvolumedata$Country == "Hong Kong"] <- "Hong Kong S.A.R."
localvolumedata$Country[localvolumedata$Country == "Tanzania"] <- "United Republic of Tanzania"

```

```{r Leaflet}
library(rgeos)
library(rworldmap)
library(leaflet)
library(rgdal)
library(jsonlite)
library(xts)

# get world map
# note must also install rworldextra

wmap <- getMap(resolution= "high")

# get centroids
centroid <- gCentroid(wmap, byid=TRUE)

# get a data.frame with centroids
mapcen <- as.data.frame(centroid)

mapcen <- cbind(rownames(mapcen), mapcen)

rownames(mapcen) <- NULL
colnames(mapcen) <- c("Country", "Lng", "Lat")

maploc <- mapcen %>%
  mutate(Country = as.character(Country))


combined_map <- localvolumedata %>%
  inner_join(maploc, by = "Country")

combined_map <- combined_map %>%
  mutate(pcolor = case_when(
    Percentage < .001 ~ rgb(241/255,196/255,15/255),
    Percentage < .01  ~ rgb(243/255,156/255,18/255),
    Percentage < .1   ~ rgb(230/255,126/255,34/255),
    Percentage < .2   ~ rgb(211/255,84/255,0/255),
    Percentage >= .2   ~ rgb(135/255,54/255,0/255)
    ))

combined_map

ico <- awesomeIcons(
  icon = "bitcoin",
  library = "glyphicon",
  markerColor = "white",
  iconColor = combined_map$pcolor
)

colorspal <- c(rgb(241/255,196/255,15/255),rgb(243/255,156/255,18/255),rgb(230/255,126/255,34/255),rgb(211/255,84/255,0/255),rgb(135/255,54/255,0/255))


world_map <- leaflet(combined_map) %>%
  addTiles() %>%
  addAwesomeMarkers(~Lng,~Lat, icon = ~ico, popup = paste("<b>Country: </b> ", combined_map$Country, "<br>","<b>Continent: </b> ", combined_map$Continent, "<br>","<b>Native Currency: </b> ", combined_map$`Native Currency`, "<br>","<b>FX Rate: </b> ", combined_map$`FX Rate`, "<br>","<b>USD Value: </b> ", combined_map$`USD Value`, "<br>", "<b>Percentage: </b> ", combined_map$Percentage, "<br>"), clusterOptions = markerClusterOptions(), label = ~Country) %>%
  addLegend(labels = ~c("<b>x < 0.1%</b>","<b>x < 1%</b>","<b>x < 10%</b>","<b>x < 20%</b>","<b>x >= 20%</b>"), colors = ~colorspal, opacity = 1, title= "Volume Percentage")
  
world_map
```

